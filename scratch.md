## Using Go kit to efficiently build microservices.---Over a series of posts, I'm going to walk through using Go and Go kit. We'll see the service evolve in complexity over time, and how Go kit makes building these services easier and boosts developer productivity.  I've spent roughly 5 years using these together, in various production environments, on multiple teams. I would describe my time using go kit as the most enjoyable & productive time of my career thus far. In this article, we'll take a look at 2 different example servers.One is using basic features of kit. The other is another open-source project built on top of kit called Gizmo.Gizmo is a more opinionated version of kit server. It comes with what I believe to be some nice abstractions/configurationoptions. It's helpful if you're somewhat familiar with `net/http` package before reading this post,but not required.---### What is Go kit and why should we consider using it?From the Kit FAQ^[https://gokit.io/faq/#what-is-go-kit]:> Go kit is a collection of Go (golang) packages (libraries) that help you build robust, reliable, maintainable microservices.> Go kit de-risks both Go and microservices by providing mature patterns and idioms, written and maintained by a largegroup of experienced contributors, and validated in production environments.//@TODO// KIT PROMOTES Good design habits and provides familiarity.---### Following life of a request to our serviceBelow is a graphic that shows the path a request takes and references the structures & functions used to carry it out.![](req-path.png)#### Transport layerHere you have the flexibility of implementing one or more transports(example HTTP/gRPC). In our example service weare using HTTP encoding a json response. The following code is defined in server/main.go in our project & we'll look atthat first.```go    svc := rawkit.NewThingSvc(logger)	getThingHandler := httptransport.NewServer(		loggingMiddleware(log.With(logger, "method", "get-a-thing"))(rawkit.GetAThingEP(svc)),		rawkit.DecodeGetThingRequest,		httptransport.EncodeJSONResponse,	)	r := mux.NewRouter()	r.Handle("/things/{id:[a-zA-Z]+}", getThingHandler).Methods("GET")    http.ListenAndServe(DEFAULT_PORT, r)// using-kit/main.go```A few things to note.1. I'm using a `Mux (gorilla) router`. There are different routers available to you with differentfeatures/performance.2. `httptransport.NewServer` is from the package `github.com/go-kit/kit/transport/http` and it creates a kit.Serverthat wraps an endpoint, a decoder for the request, and the `kit/transport/http.Server` type implements http.Handler.3. The Endpoint(which we'll talk about in a second) needs a request decoder & response encoder.4. `rawkit.GetAThing` is a function that is taking in the service we created, and returns an endpoint type.5. Again, `httptransport.NewServer` returns a struct that implements Handler interface. We register that handler with aroute and set the permitted HTTP Verbs.    ```go        r.Handle("/things/{id:[a-zA-Z]+}", getThingHandler).Methods("GET")    ```6. Finally we start listening on tcp network address and pass our router to so it replaces the `DefaultServeMux` of theserver.#### EndpointsEndpoint is the fundamental building block of servers and clients. It represents a single RPC method.Endpoint type is a function that takes in an interface request and returns an interface response. The decoder/encoderand endpoint func is where your safety and anti-fragile logic will live. Which in this example looks like this:```gofunc GetAThingEP(svc ThingSvc) endpoint.Endpoint {    return func(ctx context.Context, request interface{}) (interface{}, error) {        req := request.(GetThingRequest)        v, err := svc.GetAThing(ctx, req.ID)            if err != nil {                return GetThingResponse{*v, err.Error()}, nil            }            return GetThingResponse{*v, ""}, nil    }}```This is wrapping and calling our service. The value of request/response structs is more apparent in a microservicethat actually does things when our `GetAThing` func returns its result. In this case we are just returning to a remoteclient, so a default json encoder is also appropriate.#### ServicesA service is where your business logic should live. Start by creating an interface with methods that will eventuallywrapped by endpoints and made available at the transport layer (they don't have to be).```go    type ThingSvc interface {        GetAThing(context.Context, string) (*shared.Thing, error)        GetAllThings(context.Context) ([]shared.Thing, error)    }    type ThingService struct {    Things *shared.ThingStore    l      log.Logger}```----#### More on life cycle of the requestIt depends on your server configuration. Looking again at `kit.Server````type Server struct {e            endpoint.Endpointdec          DecodeRequestFuncenc          EncodeResponseFuncbefore       []RequestFuncafter        []ServerResponseFuncerrorEncoder ErrorEncoderfinalizer    []ServerFinalizerFuncerrorHandler transport.ErrorHandler}```The server struct offers methods to configure the package private fields. Also will depend if you configure anyadditional server options. I'm going to exclude mentioning these, but you can click into `kit/transport/http/server.go`and read the comments on when they'd run in this request path.Serve accepts incoming connections on the Listener l, creating a new service goroutine for each. The service goroutinesread requests and then call srv.Handler to reply to them. Simplest way to think about the router is an object containinga map. This map is keyed by routes that have a value of a specific handler. You can create a catch all handler,or configure a route not found method like `r.NotFoundHandler = http.NotFoundHandler()`. Assuming the req matches aroute we'll end up in our request decoder.```go    func DecodeGetThingRequest(_ context.Context, r *http.Request) (interface{}, error) {        var req GetThingRequest        req.ID = mux.Vars(r)["id"]        if len(req.ID) == 0 {            return nil, errors.New("missing ID route param")        }        return req, nil    }```Things we can do at this point: 1. Request validation. Setting some rules about what params can be passed in. 2. Accessing route variables, or decoding a request body and using these values to construct a request object for the    underlying service to work with.The next stop are the endpoint(s). We didn't mention this middleware earlier.`Middleware` is actually a defined type in `kit/endpoint` package. That type is just an `kit.endpoint`.Looking back at the main function you see we are wrapping our endpoint with a logging func.```gofunc loggingMiddleware(logger log.Logger) endpoint.Middleware {    return func(next endpoint.Endpoint) endpoint.Endpoint {        return func(ctx context.Context, request interface{}) (response interface{}, err error) {            defer func(begin time.Time) {            logger.Log("error", err, "took", time.Since(begin))        }(time.Now())            return next(ctx, request)        }    }}```Kit leans on using the decorator pattern to enforce a strict separation of concerns.We go through each endpoint, eventually getting the endpoint that has wrapped our service.```go    func GetAThingEP(svc ThingSvc) endpoint.Endpoint {        return func(ctx context.Context, request interface{}) (interface{}, error) {            req := request.(GetThingRequest)            v, err := svc.GetAThing(ctx, req.ID)            if err != nil {                return GetThingResponse{*v, err.Error()}, nil            }            return GetThingResponse{*v, ""}, nil        }}```We type cast the generic request to the one we are expecting for this route. We know this is safe after the decoderhas done its thing. From here the service retrieves data, we wrap it in a response object for the client consumingthis info. It's json encoded and sent back. I like using a response wrapper struct to wrap values and/or errors makingit easier for the client to work with.----In the next post we'll deploy this to a few different amazon/gcp services (EKS, EC2, & Lambda).all example code can be found here:https://en.wikipedia.org/wiki/Decorator_pattern